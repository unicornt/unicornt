# Report04-18307130104-赵文轩

[toc]

## 文章内容

​	作者认为，并发理论需求一个全新的概念框架，而不是仅仅在现有框架上的革新。

​	考虑一列相继运行的程序，假设没有任何的即刻输出，可以被表示成一个读入内存输出内存的函数，程序的含义可以被定义为内存->内存。而并发运行强制引入了不确定性的概念。对此，定义 P(D) 为里面的元素是D的子集，重新定义程序为 内存->P(内存)。

​	但是并发的出现导致的另一个问题是组成性的丧失，也就是合并子程序并发运行时，会产生不同的结果。因此，这个概念还需要改进，重新考虑程序和内存的交互。为此，作者用 4 张图展示了程序与内存交互模型的变化。

Figure.1: 最基础的模型，有积极/消极的区别，程序时积极的一方，内存是消极的一方。

<img src="image-20201122213304752.png" alt="Figure.1" style="zoom:67%;" />

Figure.2: 将M视作进程的状态，将变量视作程序和内存交换通道的名字。

<img src="image-20201122213324430.png" alt="Figure.2" style="zoom:67%;" />

但是将内存视作一块的想法在并发时不能成立，因为不同部分的内存可能被同时访问，因此有了下面的改进。

Figure.3: 将不同部分的内存视作分布式进程

<img src="image-20201122213346411.png" alt="Figure.3" style="zoom: 67%;" />

Figure.4: 为了破除进程是交互发起者的印象，采用了汽车接收广播信号的模型。汽车可以在附近的广播站提供的频道进行切换，而所有的广播站由中央统一管理。

<img src="image-20201122213404256.png" alt="Figure.4" style="zoom: 67%;" />



​	文章主要的思想就是如何破除传统的观念，将内存和程序视作同一种元素，而非主仆关系，从而为之后的并发模型进行铺垫。

## 我的理解

​	谈谈我对这四张图片中包含意思的理解。

​	图片1 是我们传统编程中对于内存和程序的概念，也就是程序主动访问内存，内存在等待程序的访问。为了破除这样的观念，将内存和程序拉到一个平等的地位上来，就形成了图片2所示的模型。

​	图片2 将程序和内存放在了一个平等的位置上，将变量视作程序和内存的通信，变量名就是通道的名字，变量的值通过通道传输到程序中。这样改变的好处是将内存融入到了整个模型中，内存不再是一个类似游戏贴图的东西了，而是真正变成了其中的一个模型。这就有利于对程序和内存关系的分析。但是实际上内存并非只能和一个程序交互，于是有了图片3 的改进。

​	图片3 将内存视作一个分布式的进程，能够同时和几个进程交互。可以说图片3 才算是和图片1 对等的一个模型。同时可以看到，对于多个程序对于相同内存块的竞争，变成了进程之间交互的竞争。

​	图片4 位了展现内存和进程之间的平等关系，类比了汽车的广播信号接收。

​	整个改变下来，对于如何处理并发问题有了很大的思路改变，就我阅读的想法来看，虽然我对并发理论一窍不通，但是这种改变却让我思考比如将内存访问改成服务等方法。可以说，文章开头说想要提出新的并发理论就要从内存模型上改变的话并不是空穴来风。